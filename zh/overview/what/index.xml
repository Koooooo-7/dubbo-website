<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Dubbo – Dubbo 介绍</title><link>http://static.dubbo.apache.org:8080/zh/overview/what/</link><description>Recent content in Dubbo 介绍 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://static.dubbo.apache.org:8080/zh/overview/what/index.xml" rel="self" type="application/rss+xml"/><item><title>Overview: 了解 Dubbo 的核心概念和架构</title><link>http://static.dubbo.apache.org:8080/zh/overview/what/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://static.dubbo.apache.org:8080/zh/overview/what/overview/</guid><description>
&lt;h2 id="基本架构">基本架构&lt;/h2>
&lt;p>&lt;img src="http://static.dubbo.apache.org:8080/imgs/architecture.png" alt="arch-service-discovery">&lt;/p>
&lt;p>以上是 Dubbo 的工作原理架构图，有三个核心的抽象角色：服务消费者 (Client/Consumer)、服务提供者 (Server/Provider)、服务治理中心。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>代表业务服务的消费者和提供者统称为 Dubbo 数据面&lt;/strong>，组成数据面的业务服务之间依赖 Dubbo 实现数据传输，即某个服务 (消费者) 以 RPC 或 HTTP 形式发起调用，目标服务 (提供者) 收到并回复对方的请求，Dubbo 定义了微服务开发与调用规范并完成数据传输的编解码工作。&lt;/li>
&lt;li>&lt;strong>服务治理中心控制 Dubbo 数据面的行为&lt;/strong>，比如作为注册中心协调服务组件间的地址自动发现、作为规则管控中心下发流量治理策略等。治理中心不是指如注册中心类的单个具体组件，而是 对 Dubbo 治理体系的抽象表达。&lt;/li>
&lt;/ul>
&lt;h2 id="dubbo-数据面">Dubbo 数据面&lt;/h2>
&lt;p>从数据面的视角，Dubbo 帮我们完成如下事项：&lt;/p>
&lt;ul>
&lt;li>Dubbo 作为&lt;strong>服务开发框架&lt;/strong>定义了微服务定义、开发与调用的规范&lt;/li>
&lt;li>Dubbo 作为 &lt;strong>RPC 协议实现&lt;/strong>解决服务间通信的编解码工作&lt;/li>
&lt;/ul>
&lt;p>&amp;lt;架构图&amp;gt;&lt;/p>
&lt;h3 id="服务开发框架">服务开发框架&lt;/h3>
&lt;p>就好比 Java 体系的 Spring 定义了
服务定义：IDL、Java、Golang 等
调用方式：同步、异步、Reactive
服务行为：超时、延迟注册、预热、治理中心等
配置：xml yaml properties
多语言：Java Spring、Golang xx&lt;/p>
&lt;h3 id="通信协议">通信协议&lt;/h3>
&lt;p>不绑定通信协议
流式通信模型
不绑定序列化协议
多协议暴露、同时支持单端口上的协议自动识别
高性能实现：benchmark 图&lt;/p>
&lt;p>&lt;img src="http://static.dubbo.apache.org:8080/imgs/v3/concepts/rpc.png" alt="dubbo-rpc">&lt;/p>
&lt;p>Dubbo 首先是一款 RPC 框架，它定义了自己的 RPC 通信协议与编程方式。如上图所示，用户在使用 Dubbo 时首先需要定义好 Dubbo 服务；其次，是在将 Dubbo 服务部署上线之后，依赖 Dubbo 的应用层通信协议实现数据交换，Dubbo 所传输的数据都要经过序列化，而这里的序列化协议是完全可扩展的。
使用 Dubbo 的第一步就是定义 Dubbo 服务，服务在 Dubbo 中的定义就是完成业务功能的一组方法的集合，可以选择使用与某种语言绑定的方式定义，如在 Java 中 Dubbo 服务就是有一组方法的 Interface 接口，也可以使用语言中立的 Protobuf Buffers &lt;a href="../../tasks/triple/idl/">IDL 定义服务&lt;/a>。定义好服务之后，服务端（Provider）需要提供服务的具体实现，并将其声明为 Dubbo 服务，而站在服务消费方（Consumer）的视角，通过调用 Dubbo 框架提供的 API 可以获得一个服务代理（stub）对象，然后就可以像使用本地服务一样对服务方法发起调用了。
在消费端对服务方法发起调用后，
Dubbo 框架负责将请求发送到部署在远端机器上的服务提供方，提供方收到请求后会调用服务的实现类，之后将处理结果返回给消费端，这样就完成了一次完整的服务调用。如图中的 Request、Response 数据流程所示。&lt;/p>
&lt;blockquote>
&lt;p>需要注意的是，在 Dubbo 中，我们提到服务时，通常是指 RPC 粒度的、提供某个具体业务增删改功能的接口或方法，与一些微服务概念书籍中泛指的服务并不是一个概念。&lt;/p>
&lt;/blockquote>
&lt;p>在分布式系统中，尤其是随着微服务架构的发展，应用的部署、发布、扩缩容变得极为频繁，作为 RPC 消费方，如何动态的发现服务提供方地址成为 RPC 通信的前置条件。Dubbo 提供了自动的地址发现机制，用于应对分布式场景下机器实例动态迁移的问题。如下图所示，通过引入注册中心来协调提供方与消费方的地址，提供者启动之后向注册中心注册自身地址，消费方通过拉取或订阅注册中心特定节点，动态的感知提供方地址列表的变化。&lt;/p>
&lt;p>跨进程或主机的服务通信是 Dubbo 的一项基本能力，Dubbo RPC 以预先定义好的协议编码方式将请求数据（Request）发送给后端服务，并接收服务端返回的计算结果（Response）。RPC 通信对用户来说是完全透明的，使用者无需关心请求是如何发出去的、发到了哪里，每次调用只需要拿到正确的调用结果就行。除了同步模式的 Request-Response 通信模型外，Dubbo3 还提供更丰富的通信模型选择：&lt;/p>
&lt;ul>
&lt;li>消费端异步请求(Client Side Asynchronous Request-Response)&lt;/li>
&lt;li>提供端异步执行（Server Side Asynchronous Request-Response）&lt;/li>
&lt;li>消费端请求流（Request Streaming）&lt;/li>
&lt;li>提供端响应流（Response Streaming）&lt;/li>
&lt;li>双向流式通信（Bidirectional Streaming）&lt;/li>
&lt;/ul>
&lt;h2 id="服务治理">服务治理&lt;/h2>
&lt;p>服务发现
负载均衡
动态配置
流量路由
链路追踪
服务网格&lt;/p>
&lt;h4 id="自动服务地址发现">自动服务（地址）发现&lt;/h4>
&lt;p>Dubbo 的服务发现机制，让微服务组件之间可以独立演进并任意部署，消费端可以在无需感知对端部署位置与 IP 地址的情况下完成通信。Dubbo 提供的是 Client-Based 的服务发现机制，使用者可以有多种方式启用服务发现：&lt;/p>
&lt;ul>
&lt;li>使用独立的注册中心组件，如 Nacos、Zookeeper、Consul、Etcd 等。&lt;/li>
&lt;li>将服务的组织与注册交给底层容器平台，如 Kubernetes，这被理解是一种更云原生的使用方式&lt;/li>
&lt;/ul>
&lt;h4 id="运行态流量管控">运行态流量管控&lt;/h4>
&lt;p>透明地址发现让 Dubbo 请求可以被发送到任意 IP 实例上，这个过程中流量被随机分配。当需要对流量进行更丰富、更细粒度的管控时，就可以用到 Dubbo 的流量管控策略，Dubbo 提供了包括负载均衡、流量路由、请求超时、流量降级、重试等策略，基于这些基础能力可以轻松的实现更多场景化的路由方案，包括金丝雀发布、A/B测试、权重路由、同区域优先等，更酷的是，Dubbo 支持流控策略在运行态动态生效，无需重新部署。具体可参见：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="../../tasks/traffic-management">流量治理示例&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="丰富的扩展组件及生态">丰富的扩展组件及生态&lt;/h4>
&lt;p>Dubbo 强大的服务治理能力不仅体现在核心框架上，还包括其优秀的扩展能力以及周边配套设施的支持。通过 Filter、Router、Protocol 等几乎存在于每一个关键流程上的扩展点定义，我们可以丰富 Dubbo 的功能或实现与其他微服务配套系统的对接，包括 Transaction、Tracing 目前都有通过 SPI 扩展的实现方案，具体可以参见 Dubbo 扩展性的详情，也可以在 &lt;a href="https://github.com/apache/dubbo-spi-extensions">apache/dubbo-spi-extensions&lt;/a> 项目中发现与更多的扩展实现。具体可参见：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="../../what/ecosystem">Dubbo 生态&lt;/a>&lt;/li>
&lt;li>&lt;a href="../../what/extensibility">Dubbo 可扩展性设计&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="面向云原生设计">面向云原生设计&lt;/h4>
&lt;p>Dubbo 从设计上是完全遵循云原生微服务开发理念的，这体现在多个方面，首先是对云原生基础设施与部署架构的支持，包括 容器、Kubernetes 等，Dubbo Mesh 总体解决方案也在 3.1 版本正式发布；另一方面，Dubbo 众多核心组件都已面向云原生升级，包括 Triple 协议、统一路由规则、对多语言的支持。&lt;/p>
&lt;p>值得一提的是，如何使用 Dubbo 支持弹性伸缩的服务如 Serverless 也在未来计划之中，这包括利用 Native Image 提高 Dubbo 的启动速度与资源消耗等。&lt;/p>
&lt;p>结合当前版本，本节主要从以下两点展开 Dubbo 的云原生特性&lt;/p>
&lt;ul>
&lt;li>&lt;a href="../../tasks/kubernetes/deploy-on-k8s">容器调度平台（Kubernetes）&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://static.dubbo.apache.org:8080/zh/docs3-v2/java-sdk/concepts-and-architecture/mesh/">Dubbo Mesh&lt;/a>&lt;/li>
&lt;/ul>
&lt;h5 id="kubernetes">Kubernetes&lt;/h5>
&lt;p>Dubbo 微服务要支持 Kubernetes 平台调度，最基础的就是实现 dubbo 服务生命周期与容器生命周期的对齐，这包括 Dubbo 的启动、销毁、服务注册等生命周期事件。相比于以往 Dubbo 自行定义生命周期事件，并要求开发人员在运维实践过程中遵守约定，Kubernetes 底层基础设施定义了严格的组件生命周期事件(probe)，转而要求 Dubbo 去按约定适配。&lt;/p>
&lt;p>Kubernetes Service 是另一个层面的适配，这体现了服务定义与注册向云原生底层基础设施下沉的趋势。在这种模式下，用户不再需要搭建额外的注册中心组件，Dubbo 消费端节点能自动对接到 Kubernetes（API-Server 或 DNS），根据服务名（Kubernetes Service Name） 查询到实例列表（Kubernetes endpoints）。 此时服务是通过标准的 Kubernetes Service API 定义，并被调度到各个节点。&lt;/p>
&lt;h5 id="dubbo-mesh">Dubbo Mesh&lt;/h5>
&lt;p>Service Mesh 在业界得到了广泛的传播与认可，并被认为是下一代的微服务架构，这主要是因为它解决了很多棘手的问题，包括透明升级、多语言、依赖冲突、流量治理等。Service Mesh 的典型架构是通过部署独立的 Sidecar 组件来拦截所有的出口与入口流量，并在 Sidecar 中集成丰富的流量治理策略如负载均衡、路由等，除此之外，Service Mesh 还需要一个控制面（Control Panel）来实现对 Sidecar 流量的管控，即各种策略下发。我们在这里称这种架构为经典 Mesh。&lt;/p>
&lt;p>然而任何技术架构都不是完美的，经典 Mesh 在实施层面也面临成本过高的问题&lt;/p>
&lt;ol>
&lt;li>需要运维控制面（Control Panel）&lt;/li>
&lt;li>需要运维 Sidecar&lt;/li>
&lt;li>需要考虑如何从原有 SDK 迁移到 Sidecar&lt;/li>
&lt;li>需要考虑引入 Sidecar 后整个链路的性能损耗&lt;/li>
&lt;/ol>
&lt;p>为了解决 Sidecar 引入的相关成本问题，Dubbo 引入并实现了全新的 Proxyless Mesh 架构，顾名思义，Proxyless Mesh 就是指没有 Sidecar 的部署，转而由 Dubbo SDK 直接与控制面交互，其架构图如下&lt;/p>
&lt;p>&lt;img src="http://static.dubbo.apache.org:8080/imgs/v3/mesh/dubbo-proxyless.png" alt="dubbo-proxyless">&lt;/p>
&lt;p>可以设想，在不同的组织、不同的发展阶段，未来以 Dubbo 构建的微服务将会允许有三种部署架构：传统 SDK、基于 Sidecar 的 Service Mesh、脱离 Sidecar 的 Proxyless Mesh。基于 Sidecar 的 Service Mesh，即经典的 Mesh 架构，独立的 sidecar 运行时接管所有的流量，脱离 Sidecar 的 Proxyless Mesh，副 SDK 直接通过 xDS 与控制面通信。Dubbo 微服务允许部署在物理机、容器、Kubernetes 平台之上，能做到以 Admin 为控制面，以统一的流量治理规则进行治理。&lt;/p></description></item><item><title>Overview: 核心特性</title><link>http://static.dubbo.apache.org:8080/zh/overview/what/advantages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://static.dubbo.apache.org:8080/zh/overview/what/advantages/</guid><description/></item><item><title>Overview: 与 gRPC、Spring Cloud、Service Mesh 的关系</title><link>http://static.dubbo.apache.org:8080/zh/overview/what/xyz-difference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://static.dubbo.apache.org:8080/zh/overview/what/xyz-difference/</guid><description>
&lt;p>很多开发者经常会问到 Apache Dubbo 与 Spring Cloud、gRPC 以及一些 Service Mesh 项目如 Istio 的关系，要解释清楚它们的关系并不困难，你只需要跟随这篇文章和 Dubbo 文档做一些更深入的了解，但总的来说，它们有些能力与 Dubbo 是重合的，但在一些场景你可以把它们放在一起使用。虽然这是一篇 Dubbo 维护者写的文档，我们仍会尽力将 Dubbo 与其他组件之间的联系与差异客观、透明的展现出来，但考虑到每个人对不同产品的熟悉程度不一，这里的个别表述可能并不完全准确，希望能给开发者带来帮助。&lt;/p>
&lt;h2 id="dubbo-与-spring-cloud">Dubbo 与 Spring Cloud&lt;/h2>
&lt;p>架构图&lt;/p>
&lt;p>从上图我们可以看出，Dubbo 和 Spring Cloud 有很多相似之处，它们都在整个架构图的相同位置并提供一些相似的功能。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Dubbo 和 Spring Cloud 都侧重在对分布式系统中常见问题模式的抽象（如服务发现、负载均衡、动态配置等）&lt;/strong>，同时对每一个问题都提供了配套组件实现，形成了一套微服务整体解决方案，让使用 Dubbo 及 Spring Cloud 的用户在开发微服务应用时可以专注在业务逻辑开发上。&lt;/li>
&lt;li>&lt;strong>Dubbo 和 Spring Cloud 都完全兼容 Spring 体系的应用开发模式&lt;/strong>，Dubbo 对 Spring 应用开发框架、Spring Boot 微服务框架都做了很好的适配，由于 Spring Cloud 出自 Spring 体系，在这一点上自然更不必多说。&lt;/li>
&lt;/ul>
&lt;p>虽然两者有很多相似之处，但由于它们在诞生背景与架构设计上的巨大差异，两者在性能、适用的微服务集群规模、生产稳定性保障、服务治理等方面都有很大差异。&lt;/p>
&lt;p>Spring Cloud 的优势在于：&lt;/p>
&lt;ul>
&lt;li>同样都支持 Sprig 开发体系的情况下，Spring Cloud 得到更多的原生支持&lt;/li>
&lt;li>对一些常用的微服务模式做了抽象如服务发现、动态配置、异步消息等，同时包括一些批处理任务、定时任务、持久化数据访问等领域也有涉猎。&lt;/li>
&lt;li>基于 HTTP 的通信模式，加上相对比较完善的入门文档和演示 demo 和 starters，让开发者在第一感觉上更易于上手&lt;/li>
&lt;/ul>
&lt;p>Spring Cloud 的问题有：&lt;/p>
&lt;ul>
&lt;li>只提供抽象模式的定义不提供官方稳定实现，开发者只能寻求类似 Netflix、Alibaba、Azure 等不同厂商的实现套件，而每个厂商支持的完善度、稳定性、活跃度各异&lt;/li>
&lt;li>有微服务全家桶却不是能拿来就用的全家桶，demo 上手容易，但落地推广与长期使用的成本非常高&lt;/li>
&lt;li>欠缺服务治理能力，尤其是流量管控方面如负载均衡、流量路由方便能力都比较弱&lt;/li>
&lt;li>编程模型与通信协议绑定 HTTP，在性能、与其他 RPC 体系互通上存在障碍&lt;/li>
&lt;li>总体架构与实现只适用于小规模微服务集群实践，当集群规模增长后就会遇到地址推送效率、内存占用等各种瓶颈的问题，但此时迁移到其他体系却很难实现&lt;/li>
&lt;li>很多微服务实践场景的问题需要用户独自解决，比如优雅停机、启动预热、服务测试，再比如双注册、双订阅、延迟注册、服务按分组隔离、集群容错等&lt;/li>
&lt;/ul>
&lt;p>而以上这些点，都是 &lt;strong>Dubbo 的优势&lt;/strong>所在：&lt;/p>
&lt;ul>
&lt;li>完全支持 Spring &amp;amp; Spring Boot 开发模式，同时在服务发现、动态配置等基础模式上提供与 Spring Cloud 对等的能力。&lt;/li>
&lt;li>是企业级微服务实践方案的整体输出，Dubbo 考虑到了企业微服务实践中会遇到的各种问题如优雅上下线、多注册中心、流量管理等，因此其在生产环境的长期维护成本更低&lt;/li>
&lt;li>在通信协议和编码上选择更灵活，包括 rpc 通信层协议如 HTTP、HTTP/2(Triple、gRPC)、TCP 二进制协议、rest等，序列化编码协议Protobuf、JSON、Hessian2 等，支持单端口多协议。&lt;/li>
&lt;li>Dubbo 从设计上突出服务服务治理能力，如权重动态调整、标签路由、条件路由等，支持 Proxyless 等多种模式接入 Service Mesh 体系&lt;/li>
&lt;li>高性能的 RPC 协议编码与实现，&lt;/li>
&lt;li>Dubbo 是在超大规模微服务集群实践场景下开发的框架，可以做到百万实例规模的集群水平扩容，应对集群增长带来的各种问题&lt;/li>
&lt;li>Dubbo 提供 Java 外的多语言实现，使得构建多语言异构的微服务体系成为可能&lt;/li>
&lt;/ul>
&lt;p>Dubbo 也有一些欠缺的地方，尤其是资料的欠缺使得入门门槛略高，体现在依赖配置管理、文档、demo 示例完善度上，当前整个社区在重点投入这一部分的建设，期望能降低用户在第一天体验和学习 Dubbo 时的门槛。&lt;/p>
&lt;p>如果您的目标是构建企业级应用，并期待在未来的持久维护中能够更省心、更稳定，我们建议你能更深入的了解 Dubbo 的使用和其提供的能力。&lt;/p>
&lt;h2 id="dubbo-与-grpc">Dubbo 与 gRPC&lt;/h2>
&lt;p>gRPC 定位为一款 RPC 框架，而 Dubbo&lt;/p>
&lt;p>Dubbo 完全兼容 gRPC，并将 gRPC 设计为内置支持的最重要的协议之一。&lt;/p>
&lt;h2 id="dubbo-与-service-mesh">Dubbo 与 Service Mesh&lt;/h2>
&lt;p>Dubbo Service Mesh&lt;/p>
&lt;p>&amp;lt;架构图&amp;gt;&lt;/p>
&lt;p>从&lt;strong>数据面&lt;/strong>的视角，Dubbo 与 Istio、Consul、Linkerd 等控制面之间是无缝接入和合作关系，&lt;/p>
&lt;ul>
&lt;li>作为，Dubbo 将作为编程框架 &amp;amp; 通信组件而存在，&lt;/li>
&lt;li>对于 Dubbo Proxyless 模式，Dubbo 可以通过标准 xDS 协议接入 Istio、Consul、Linkerd 等控制面组件，&lt;/li>
&lt;/ul>
&lt;p>从&lt;strong>控制面&lt;/strong>视角，Dubbo 体系基于 Istio 给出了自己的定制版本控制面实现，&lt;/p></description></item><item><title>Overview: 可观测性</title><link>http://static.dubbo.apache.org:8080/zh/overview/what/observability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://static.dubbo.apache.org:8080/zh/overview/what/observability/</guid><description/></item></channel></rss>